package sudoku;

import java.util.*;
import java.util.stream.Collectors;




public class ValidationError {
    private final String type;
    private final int index;
    private final Map<Integer, Set<Integer>> valueToPositions; // Value -> Positions map
    private final Set<Integer> missingNumbers;

    public ValidationError(String type, int index, 
                         Map<Integer, Set<Integer>> valueToPositions,
                         Set<Integer> missingNumbers) {
        this.type = type;
        this.index = index;
        this.valueToPositions = valueToPositions;
        this.missingNumbers = missingNumbers;
    }

    // Keep old constructor for compatibility
    public ValidationError(String type, int index,
                         Set<Integer> duplicateValues,
                         Set<Integer> duplicatePositions,
                         Set<Integer> missingNumbers) {
        this.type = type;
        this.index = index;
        this.missingNumbers = missingNumbers;
        this.valueToPositions = new HashMap<>();
        
    }


    public String toString() {
    StringBuilder sb = new StringBuilder();
    
    for (Map.Entry<Integer, Set<Integer>> entry : valueToPositions.entrySet()) {
        if (entry.getValue().size() > 1) {
            // Convert 0-based positions to 1-based for display
            Set<Integer> displayPositions = entry.getValue().stream()
                .map(pos -> pos + 1)
                .collect(Collectors.toSet());
                
            sb.append(String.format("  %s %d, #%d, positions=%s\n",
                type, index + 1, entry.getKey(), displayPositions));
        }
    }
    
    
        
        // Print missing numbers
        if (!missingNumbers.isEmpty()) {
            sb.append(String.format("  %s %d, Missing: %s\n", 
                    type, index + 1, missingNumbers));
        }
        
        return sb.toString().trim(); // Remove trailing newline
    }
}

